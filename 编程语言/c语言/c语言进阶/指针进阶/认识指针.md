---
tags:
  - c语言
  - 指针
---
## 指针的声明

### 指针的初始化
在数据类型后面跟星号，再加上指针变量的名字可以声明指针。
```c
int *p; //声明一个整数指针
```
星号两边的空白符不影响指针的声明。
**星号将变量声明为指针。这是一个重载过的符号，因为它也用在乘法和解引指针上。**

#### 地址操作符
地址操作符`&`会返回操作数的地址。我们可以用这个操作符来初始化pi指针 [[单目操作符#^fdf130|取地址]]
```c
int num=0;
int* pi=&num;
```

##### 强制类型转换
```c
int num=0;
int* pi=(int*)num;  //语法正确，编译器给出警告
```
强制类型转换声明指针，**解引用指针时**程序会因为非法访问内存崩溃[[单目操作符#^4f861d|强制类型转换的用法]]


#### 打印地址
```c
int* pi=num;
printf("%p\n",pi);  //打印pi的地址
```

##### 虚拟内存和指针
在虚拟操作系统上显示的指针地址一般不是真实的物理内存地址。虚拟操作系统允许程序分布在机器的物理地址空间上。应用程序分为页（或帧），这些页表示内存中的区域。应用程序的页被分配在不同的（可能是不相邻的）内存区域上，而且可能不是同时处于内存中。如果操作系统需要占用被某一页占据的内存，可以将这些内存交换到二级存储器中，待将来需要时再装载进内存中（内存地址一般都会与之前的不同）。这种能力为虚拟操作系统管理内存提供了相当大的灵活性。

每个程序都假定自己能够访问机器的整个物理内存空间，实际上却不是。程序使用的地址是虚拟地址。操作系统会在需要时把虚拟地址映射为物理内存地址。

这意味着页中的代码和数据在程序运行时可能位于不同的物理位置。应用程序的虚拟地址不会变，就是我们在查看指针内容时看到的地址。操作系统会帮我们将虚拟地址映射为真实地址。

### 解引用指针
间接引用操作符`*`返回指针变量指向的值，一般称为解引指针。
```c
int num=5;
int* p=&num;
printf("%d",*p);  //输出5
```


## null的概念
NULL被赋值给指针就意味着指针不指向任何东西。null概念是指指针包含了一个特殊的值，它没有指向任何内存区域。


指针可以赋0，但是不能赋任何别的整数值
```c
pi=0;
pi=NULL;
```


指针可以作为逻辑表达式的唯一操作数。可以用下面的代码来测试指针是否设置成了NULL
```c
if(pi){
}
else{
}
```
如果这里pi被赋了NULL值，那就会被解释为二进制0。在C中这表示假


## 指针传参

#### 节省内存
C 语言的传值机制（Pass by Value）：
- 默认机制：复制一份（浪费空间）
- 在 C 语言中，把一个变量传给函数时，默认动作是“克隆”**。系统会在栈内存（Stack）中开辟一块新的空间，把原来的数值完全**复制**过去

- 指针传参：系统只需要传递一个**地址**。


#### 修改实参

除了省空间，指针传参还有一个功能上的绝对优势：**允许函数修改外部变量的值**。

C 语言的函数是“单向传输”的。如果传入的是普通变量，函数内部修改的只是那个“副本”，原本的变量不会受影响。