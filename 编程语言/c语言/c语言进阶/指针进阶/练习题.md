---
tags:
  - c语言
  - 指针
---

### 数组指针

^1af50c

```c
#include <stdio.h>

int main() {
    char *s[] = {"Knowledge", "is", "power"};
    char **p = s;
    printf("%s", *(p + 1) + 1);
    return 0;
}
```
步骤解析：

1. `s` 是一个指针数组，`p` 指向 `s` 的首地址，即指向 `s[0]`。
    
2. `p + 1` 指向 `s[1]`（因为 `p` 是 `char**`，步长是一个指针的大小）。
    
3. `*(p + 1)` 取出 `s[1]` 的内容，即字符串 "is" 的首地址。
    
4. 对该地址再 `+ 1`，指针移动到字符 'i' 之后，即指向 's'。
    
5. `%s` 从该位置打印直到结束，输出 "s"。

### 函数指针数组

^ca1659

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    int (*funcs[])(int, int) = {add, sub};
    printf("%d", (*(funcs + 1))(5, 3));
    return 0;
}
```
步骤解析：

1. `funcs` 是一个函数指针数组。
    
2. `funcs + 1` 指向数组的第二个元素，即函数 `sub` 的指针地址。
    
3. `*(funcs + 1)` 解引用得到函数指针 `sub`。
    
4. 调用 `sub(5, 3)`，执行 `5 - 3`，结果为 `2`。

预测第一次 printf 的输出：
```c
#include <stdio.h>
int main() {
    char *c[] = {"ENTER", "NEW", "POINT", "FIRST"};
    char **cp[] = {c+3, c+2, c+1, c};
    char ***cpp = cp;
    printf("%s", **++cpp);
    printf("%s", *--*++cpp+3);
    return 0;
}
```
`cpp` 指向 `cp[0]`。`++cpp` 使其指向 `cp[1]`。`*cpp` 得到 `cp[1]` 的值，即 `c+2`（指向 "POINT" 的指针）。再次 `*` 解引用得到 "POINT" 字符串的首地址。

步骤：

1. `++cpp`：`cpp` 再次自增，现指向 `cp[2]`。
    
2. `*++cpp`：取出 `cp[2]` 的内容，即 `c+1`（指向 "NEW" 的指针）。
    
3. `--`：对刚才取出的指针（注意这是 `cp[2]` 中的值）进行前缀自减。`c+1` 变为 `c`（指向 "ENTER" 的指针）。注意这修改了 `cp[2]` 的内容。
    
4. `*`：解引用 `c`，得到字符串 "ENTER"。
    
5. `+3`：指针移动 3 位，指向 "ENTER" 中的 'E'，输出 "ER"。


察多维数组指针的类型转换与步长，预测输出：
```c
#include <stdio.h>
int main() {
    int a[5][5];
    int (*p)[4];
    p = (int(*)[4])a;
    printf("%ld", &p[3][3] - &a[3][3]);
    return 0;
}
```
内存布局分析：
1. `&a[3][3]`：在 `a`（每行5个）中，位置是 `3*5 + 3 = 18`。
    
2. `&p[3][3]`：`p` 认为每行只有4个元素，位置是 `3*4 + 3 = 15`。
    
3. 两者都指向同一个 int 数组的内存区域。相减结果为索引差：`15 - 18 = -3`。

复杂声明解析。请问变量 `foo` 的类型是什么？
```c
void (*foo(int, void (*)(int)))(int);
```
解析顺序：

1. `foo(int, ...)`：foo 是一个函数。
    
2. 参数是 `int` 和 `void (*)(int)`（一个函数指针）。
    
3. 返回类型：去掉 `foo(...)` 后剩下 `void (*)(int)`，即返回一个指向“接受int参数且无返回值”的函数的指针。