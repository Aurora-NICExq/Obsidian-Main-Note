---
tags:
  - c语言
  - 指针
---

函数指针指向函数的指针

## 函数的地址

### 函数取地址

```c
int Add(int x,int y){
  return x+y;
}
printf("%p",&Add);  //打印函数Add的地址
```

操作符`&`可以取出函数在内存中的地址



### 函数的地址分配

**函数编译后的二进制代码（指令）必须存储在内存中**才能被 CPU 执行。函数名本质上就是这块代码在内存中的**起始地址**（入口地址）。

与数组名类似，函数名本身在大多数表达式中就会**自动退化**为指向该函数的指针。[[数组#^29dcc1|数组退化]]

#### 函数在内存中的位置

##### 静态内存

在程序运行时，内存通常被划分为几个区域（栈区、堆区、全局区等）。 函数体内的指令（机器码）通常存储在 **代码段 (Code Segment / Text Segment)**。 当调用一个函数（比如 `test()`）时，CPU 其实就是拿到了 `test` 的地址，然后跳转（Jump）到那个内存地址去执行指令。函数指针指向了在代码段中的起始地址



##### 动态内存：栈

函数调用的时候，在内存中存放：函数的局部变量（`int a`）、形式参数、返回地址。

- 函数调用期间：压入栈帧，占据内存
- 当函数**返回**（return）时，栈帧弹出，这部分内存被释放给其他函数使用。



#### 代码块示例

```c
#include <stdio.h>

void my_function() {
    int local_var = 100;
    printf("函数运行时 - 局部变量(栈帧)的地址: %p\n", &local_var);
}

int main() {
    // 1. 还没有调用函数，先打印函数的地址
    printf("函数未调用 - 函数代码(代码段)的地址: %p\n", my_function);

    // 2. 调用函数
    my_function();
    
    // 3. 再次调用函数
    my_function();

    return 0;
}
```



## 函数指针



### 函数指针示例

```c
#include <stdio.h>

int add(int x, int y) {
    return x + y;
}

int main() {
    // 定义一个函数指针 p，它可以指向一个 "接收两个int并返回int" 的函数
    int (*p)(int, int); 
    
    // 把 add 函数的地址赋给 p
    p = &add; // 或者写 p = add; 也可以
    
    // 通过地址调用函数
    int result = (*p)(10, 20); // 或者简写为 p(10, 20);
    
    printf("结果是: %d\n", result); // 输出 30
    
    return 0;
}
```



#### 函数指针的解引用

C语言在处理函数调用时的一条规则：**函数指示符（Function Designator）会自动转换为指向函数的指针。**

因此：无限地解引用，或者完全不解引用，结果都是一样的。



#### 解引用示例

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }

int main() {
    int (*p)(int, int) = add;

    int r1 = p(10, 20);          // 写法 1：直接使用指针（最现代）
    int r2 = (*p)(10, 20);       // 写法 2：标准解引用（经典）
    int r3 = add(10, 20);        // 写法 3：直接使用函数名
    int r4 = (&add)(10, 20);     // 写法 4：显式取地址（合法）
    int r5 = (******p)(10, 20);  // 写法 5：合法

    printf("%d, %d, %d, %d, %d\n", r1, r2, r3, r4, r5);
    return 0;
}
```



### 函数指针使用场景

[[编程语言/c语言/c语言进阶/指针进阶/练习题#^ca1659|习题]]

#### 转移表 (Jump Table) —— 替代冗长的 Switch-Case

**作用：** 消除复杂的 `if-else` 或 `switch` 分支，提高代码的可读性和执行效率（O(1) 复杂度）。

```c
#include <stdio.h>

void file_open()  { printf("执行操作：打开文件\n"); }
void file_save()  { printf("执行操作：保存文件\n"); }
void file_close() { printf("执行操作：关闭文件\n"); }
void file_exit()  { printf("执行操作：退出程序\n"); }

int main() {
    // 定义一个函数指针数组
    // 数组的每个元素都是一个指向 void func() 的指针
    void (*menu_actions[])() = {  //这里是一个指向函数的指针的数组
        file_open,  // 索引 0
        file_save,  // 索引 1
        file_close, // 索引 2
        file_exit   // 索引 3
    };

    int choice;
    printf("请输入菜单选项 (0=Open, 1=Save, 2=Close, 3=Exit): ");
    scanf("%d", &choice);

    if (choice >= 0 && choice <= 3) {
        // 直接通过数组索引调用函数，不需要 switch-case
        menu_actions[choice](); 
    } else {
        printf("无效选项\n");
    }

    return 0;
}
```



#### 模拟面向对象 (Polymorphism) —— 硬件抽象层 (HAL)

**作用：** 定义统一的接口，隐藏底层的不同实现。

```c
#include <stdio.h>

// 定义一个“接口”：也就是一个包含函数指针的结构体
struct Driver {
    char *name;
    void (*init)(void);   // 初始化函数的指针
    void (*read)(void);   // 读取数据的指针
};

// --- 下面是 USB 驱动的实现 ---
void usb_init() { printf("USB 驱动初始化...\n"); }
void usb_read() { printf("从 USB 读取数据...\n"); }

// --- 下面是 SD 卡驱动的实现 ---
void sd_init()  { printf("SD 卡驱动初始化...\n"); }
void sd_read()  { printf("从 SD 卡读取数据...\n"); }

int main() {
    // 我们可以创建一个通用的驱动指针
    struct Driver current_device;

    // 假设用户选择了 USB
    int user_selection = 1; // 1代表USB

    if (user_selection == 1) {
        current_device.name = "USB 3.0";
        current_device.init = usb_init; // 挂载 USB 的函数
        current_device.read = usb_read;
    } else {
        current_device.name = "SanDisk SD";
        current_device.init = sd_init;  // 挂载 SD 的函数
        current_device.read = sd_read;
    }

    // --- 业务逻辑层 ---
    // 注意：这里的代码完全不关心底层是 USB 还是 SD 卡
    // 它只管调用结构体里的函数指针
    printf("当前设备: %s\n", current_device.name);
    current_device.init();  // 多态调用
    current_device.read();  // 多态调用

    return 0;
}
```



#### 回调函数 (Callback)

**作用：** 编写通用的库函数（如 `qsort`），让使用者决定具体怎么做。

```c
#include <stdio.h>

// 1. 定义一个函数指针类型，为了代码好读
// 这个类型代表：接收一个 int，返回 void 的函数
typedef void (*Task)(int); 

// 2. 这是一个通用的处理函数
// 它负责遍历数组（脏活累活），但具体怎么处理每个数字，由参数 func 决定
void process_array(int *arr, int size, Task func) {
    for (int i = 0; i < size; i++) {
        // 调用传入的函数
        func(arr[i]); 
    }
    printf("\n");
}

// 具体行为 A：打印数字
void print_num(int n) {
    printf("%d ", n);
}

// 具体行为 B：打印数字的平方
void print_square(int n) {
    printf("[%d] ", n * n);
}

int main() {
    int data[] = {1, 2, 3, 4, 5};
    int len = 5;

    printf("模式 1 (普通打印): ");
    process_array(data, len, print_num); // 传入 print_num 函数的地址

    printf("模式 2 (平方打印): ");
    process_array(data, len, print_square); // 传入 print_square 函数的地址

    return 0;
}
```



## 函数指针进阶



### 进阶一：配合 `void*` 实现“泛型”编程

C 语言没有 C++ 的模板（Template），也没有 Java 的泛型（Generic），但我们可以通过 `void*` + `函数指针` 来实现类似的效果。

**核心思想：** 我不知道你要处理的数据类型是什么，所以我用 `void*` 指向数据，然后请你给我传一个“知道怎么处理 `void*`”的函数指针。

**最经典案例：标准库的 `qsort`** `qsort` 可以排序整数、浮点数、字符串、结构体，它怎么做到的？

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[20];
    int age;
} Person;

// 比较函数：必须符合 int (*)(const void*, const void*) 的签名
// 注意：参数是 void*，意味着它不知道传进来的是 Person
int compare_person_age(const void *a, const void *b) {
    // 1. 强制类型转换：把 void* 转回 Person*
    const Person *p1 = (const Person *)a;
    const Person *p2 = (const Person *)b;
    
    // 2. 进行比较
    return p1->age - p2->age;
}

int main() {
    Person team[] = { {"Alice", 30}, {"Bob", 20}, {"Charlie", 25} };
    
    // 调用 qsort
    // 第4个参数就是函数指针。qsort 内部只负责交换内存，比较大小逻辑完全外包给你。
    qsort(team, 3, sizeof(Person), compare_person_age);

    for(int i=0; i<3; i++) {
        printf("%s: %d\n", team[i].name, team[i].age);
    }
    return 0;
}
```

> **掌握：** 如何编写接收 `void*` 参数的函数，并在内部安全地进行类型转换。



### 进阶二：带“上下文”的回调 (Context/User Data)

在简单的回调中，我们只传递函数指针。但在工程中，这通常是不够的。

比如：想写一个函数“每秒钟打印一次数字”，但希望第一次调用打印 1，第二次打印 2…… 如果只传函数指针，这个函数内部就必须使用**全局变量**来记录“当前打印到几了”。

**解决方案：** 传递函数指针的同时，传递一个 `void* arg`（上下文数据）。

```c
#include <stdio.h>

// 定义回调类型：不仅接收事件，还接收一个“用户数据”
typedef void (*EventHandler)(const char *msg, void *arg);

// 模拟一个库函数
void start_work(EventHandler callback, void *user_data) {
    // 库函数在调用回调时，原封不动地把 user_data 传回去
    callback("任务完成", user_data);
}

// 你的回调函数
void my_callback(const char *msg, void *arg) {
    int *counter = (int *)arg; // 取出上下文
    (*counter)++;              // 修改上下文
    printf("%s, 当前计数: %d\n", msg, *counter);
}

int main() {
    int count = 100; // 这是我想在回调里维护的状态（局部变量）
    
    // 把 &count 作为“背包”传递给回调函数
    start_work(my_callback, &count);
    start_work(my_callback, &count);
    
    return 0;
}
```

> **掌握：** 永远不要只设计 `void (*f)()` 的接口，最好设计成 `void (*f)(void *context)`。这能让回调函数拥有“状态”，且不需要全局变量。



### 右左法则 (The Right-Left Rule)

```c
void (*(*fp)(int))[10];
```

**阅读方法：**

1. 找到变量名 `fp`。
2. **往右看**，遇到 `)`，调头。
3. **往左看**，遇到 `*`。 -> **`fp` 是一个指针。**
4. 跳出括号，**往右看**，遇到 `(int)`。 -> **指向一个函数（参数是 int）。**
5. **往左看**，遇到 `*`。 -> **该函数返回一个指针。**
6. 跳出括号，**往右看**，遇到 `[10]`。 -> **指向一个包含10个元素的数组。**
7. **往左看**，遇到 `void`。 -> **数组存的是 void（这通常是 void*，这里为了简化写 void）。**

**总结：** `fp` 是一个指向函数的指针，该函数接受 int 参数，返回一个指向包含 10 个 void 元素的数组的指针。
