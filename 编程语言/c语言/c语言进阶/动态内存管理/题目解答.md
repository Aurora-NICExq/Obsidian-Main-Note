### 核心结论

这段代码在运行时会发生**崩溃（Crash）**，通常表现为 `Segmentation Fault`（段错误）。

### 2. 涉及的知识点

- **函数参数传递机制（值传递）：** C语言中函数参数默认是按值传递的（Pass by Value）。
    
- **指针的本质：** 指针变量本身也是一个变量，存储的是地址。
    
- **动态内存分配（`malloc`）：** 堆内存的申请与生命周期。
    
- **内存访问违规：** 试图向 NULL 指针（空地址）写入数据。
    
- **内存泄漏（Memory Leak）：** 申请的堆内存未释放且丢失了引用。
    

### 3. 代码详细分析与思考思路

我们要追踪 `str` 这个指针变量的变化过程：

1. **初始化：**
    
    - 在 `Test` 函数中，`char *str = NULL;`。
        
    - 此时 `str` 指向的地址是 `0x0`（空）。
        
2. **调用函数 `GetMemory(str)`：**
    
    - 这是问题的关键。调用函数时，C语言会将实参 `str` 的**值**（即 `NULL`）拷贝一份，传递给形参 `p`。
        
    - **重点：** 此时 `GetMemory` 中的 `p` 是 `str` 的一份拷贝。`p` 和 `str` 是两个独立的变量，虽然它们存的值暂时相同，但它们在栈内存中的位置不同。
        
3. **在 `GetMemory` 内部：**
    
    - `p = (char *)malloc(100);`
        
    - 系统在堆（Heap）上分配了100字节的内存，假设地址是 `0x1234`。
        
    - **形参 `p`** 被赋值为 `0x1234`。
        
    - **实参 `str`** 依然是 `NULL`。因为修改副本 `p` 不会影响原件 `str`。
        
    - 函数执行完毕，`p` 作为局部变量被销毁。刚才申请的那 100 字节内存（`0x1234`）依然存在，但已经没有任何指针指向它了——这就造成了**内存泄漏**。
        
4. **回到 `Test` 函数：**
    
    - 代码执行到 `strcpy(str, "hello world");`。
        
    - 此时 `str` 的值仍然是 `NULL`。
        
    - `strcpy` 试图向地址 `0x0` 写入数据 "hello world"。
        
    - 在操作系统中，0地址是受保护的保留区，禁止写入。
        
    - **结果：程序崩溃。**
        

### 4. 正确的写法

要解决这个问题，目的是让 `GetMemory` 能够修改 `Test` 中 `str` 的值。有两种常见的改法：

#### 方法一：使用二级指针（推荐）

如果你想在函数内部修改一个指针的值，你必须传递这个指针的地址（即指针的指针）。
```c
// 参数改为 char **p
void GetMemory(char **p) 
{
    // *p 代表解引用，直接操作外面的 str
    *p = (char *)malloc(100); 
}

void Test(void) 
{
    char *str = NULL;
    GetMemory(&str); // 传递 str 的地址
    if (str != NULL) {
        strcpy(str, "hello world");
        printf(str);
        free(str); // 记得释放内存！
        str = NULL;
    }
}
```

#### 方法二：利用函数返回值

让函数返回分配好的内存地址。
```c
char *GetMemory(void) 
{
    char *p = (char *)malloc(100);
    return p; // 返回地址
}

void Test(void) 
{
    char *str = NULL;
    str = GetMemory(); // 接收返回值
    if (str != NULL) {
        strcpy(str, "hello world");
        printf(str);
        free(str); // 记得释放内存！
        str = NULL;
    }
}
```