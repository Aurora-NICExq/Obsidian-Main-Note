---
tags:
  - c语言
---

### 为什么要进行动态内存分配？

如果只使用静态或自动内存（如声明 `int arr[100];`），会遇到以下局限性，而动态内存（Heap/堆区）解决了这些问题：

- 空间大小的不确定性：
  - *静态做法：* 必须预估一个最大值（如 `char buffer[10000];`），这不仅浪费空间，而且如果数据超过该值会导致溢出。
  - *动态做法：* 可以根据实际需要申请精确的大小。
- **生命周期的控制（Persistence）：**
  - *栈（Stack）内存：* 函数内的局部变量在函数结束时会自动销毁。如果想在函数 `create_node()` 中创建一个对象，并在函数返回后继续在 `main()` 中使用它，栈内存是做不到的。
  - *堆（Heap）内存：* 动态分配的内存会一直存在，直到显式释放它。这允许数据跨函数传递。
- **栈空间有限：** 栈空间通常很小（通常几 MB）。如果尝试在栈上声明一个巨大的数组（例如处理高分辨率图像矩阵），会导致 **Stack Overflow**（栈溢出）。堆空间则大得多，受限于物理内存。



### 常见的动态内存函数

这些函数都声明在 `<stdlib.h>` 头文件中：

| **函数名**  | **原型**                                    | **描述**                               | **关键特点**                                   |
| ----------- | ------------------------------------------- | -------------------------------------- | ---------------------------------------------- |
| **malloc**  | `void* malloc(size_t size)`                 | 分配指定字节数的内存块。               | **内容未初始化**（包含随机垃圾值）。           |
| **calloc**  | `void* calloc(size_t num, size_t size)`     | 分配 `num` 个元素，每个大小为 `size`。 | **内容初始化为 0**。比 malloc 稍慢，但更安全。 |
| **realloc** | `void* realloc(void* ptr, size_t new_size)` | 调整已分配内存块的大小。               | 可以扩大或缩小。移动数据到新地址。             |
| **free**    | `void free(void* ptr)`                      | 释放之前分配的内存。                   | 必须成对出现，否则导致内存泄漏。               |



使用`realloc`调整内存空间大小后，原空间的内存被自动释放



### 代码示例

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 1. 使用 malloc 分配 10 个 int 的空间
    int *arr = (int*)malloc(10 * sizeof(int));
    
    // 检查是否分配成功（非常重要！）
    if (arr == NULL) {    //malloc分配内存失败时返回空指针，对空指针解引用程序会出错
        printf("Memory allocation failed");
        return 1;
    }

    // 2. 使用内存
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }

    // 3. 假设空间不够，使用 realloc 扩容到 20 个
    int *temp = (int*)realloc(arr, 20 * sizeof(int));
    if (temp != NULL) {
        arr = temp; // 只有成功时才更新指针
    } else {
        free(arr); // realloc 失败，原内存仍在，需处理
        return 1;
    }

    // 4. 释放内存
    free(arr);
    arr = NULL; //以此避免悬挂指针

    return 0;
}
```



## 常见的动态内存错误

#### 内存泄漏 (Memory Leak)

**描述：** 分配了内存但忘记使用 `free()` 释放。 **后果：** 程序运行时间越长，占用的内存越多，最终导致系统崩溃。

例外：`main`函数结束后系统自动回收内存空间，此时如果没有使用`free`函数不一定导致内存泄露

```c
void leak_memory() {
    int *ptr = malloc(sizeof(int));
    *ptr = 10;
    // 函数结束，ptr 变量销毁，但它指向的堆内存依然被占用，且无法再访问。
    return; 
}
```

#### 野指针 (Dangling Pointer)

**描述：** 释放内存后，继续使用该指针。 **后果：** 数据损坏或程序崩溃（Segfault）。

```c
free(ptr);
// ... 一些代码后 ...
*ptr = 5; // 错误
```



#### 重复释放 (Double Free)

**描述：** 对同一块内存地址调用了两次 `free()`。 **后果：** 破坏堆内存管理器的元数据，导致程序立即崩溃或产生难以排查的漏洞。



#### 对非动态开辟内存`free`释放

```c
int a;
int* p=&a;
free(p);
```



#### 越界访问 (Buffer Overflow)

**描述：** 写入的数据超过了分配的大小。堆内存通常是连续的，越界会覆盖相邻的数据块（可能是其他变量或堆管理信息）。

```c
int *arr = malloc(5 * sizeof(int)); // 分配了 arr[0] 到 arr[4]
arr[5] = 100; // 越界访问数组
```



#### 忘记检查 NULL

**描述：** 在内存耗尽时，`malloc` 会返回 `NULL`。如果不检查直接使用，会导致程序崩溃。

------



### 题目示例

传入参数无法修改实参：

```c
void GetMemory(char *p)
{
    p = (char *)malloc(100);
}

void Test(void)
{
    char *str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

[[题目解答]]



### 总结

动态内存分配是 C 语言灵活性的来源，也是其复杂性的根源。掌握它的核心在于：**“谁申请，谁释放”** 的原则，以及对指针生命周期的严格管理。