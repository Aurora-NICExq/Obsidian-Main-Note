---
tags:
  - c语言
  - DataStructure
---
## 链表基本结构
`LNode`和`*LinkList`的声明原因 ^8047a0
```c
typedef struct Node {
    int data;
    struct Node *next;
} LNode, *LinkList;
```
代码执行了以下两步：

1. **`typedef struct Node LNode;`**
    - 意味着：`LNode` 等价于 `struct Node`（结点实体）。
2. **`typedef struct Node *LinkList;`**
    - 意味着：`LinkList` 等价于 `struct Node *`（指向结点的指针）。
所以，**`LinkList L;` 完全等价于 `LNode *L;`**。

### 使用区分
#### 何时使用 `LinkList`？

想表达“这是一个链表”**的时候。 通常用于定义函数的返回值，或者定义头指针。
- **例子**：
```c
// 这种写法让人一眼就明白：函数返回的是一个“链表”
LinkList InitList() { ... } 

// 定义一个链表 L
LinkList L;
```

#### 何时使用 `LNode *`？

当你想表达**“这是一个指向某个结点的指针”**的时候。 通常用于遍历链表时，定义临时的指针变量。
```c
// 这种写法让人明白：p 是用来指向某个具体结点的
LNode *p = L->next;
```

#### 两者对比
写法 1（不区分，混着用）：
```c
// 读起来很费劲：为什么返回个结点指针？L 又是什么？
struct Node* GetElem(struct Node* L, int i) {
    struct Node* p = L;
    // ...
}
```

写法 2（区分使用，逻辑清晰）：
```c
// 读起来很舒服：
// 在链表 L 中查找，返回找到的那个结点（LNode*）
LNode* GetElem(LinkList L, int i) {
    LNode *p = L; // p 是跑腿的，用来指向当前遍历到的结点
    // ...
}
```
### 总结

- **`LinkList`**：侧重于**宏观**。代表**整个链表**的对象（通常指头指针）。它隐藏了 `*` 号，让你感觉像是在操作一个对象。
    
- **`LNode *`**：侧重于**微观**。代表**链表中的某一个结点**。它保留了 `*` 号，提醒你这只是一个指向局部的指针。
    

**一句话口诀：** **定义链表头用 `LinkList`，遍历找人用 `LNode *`。**