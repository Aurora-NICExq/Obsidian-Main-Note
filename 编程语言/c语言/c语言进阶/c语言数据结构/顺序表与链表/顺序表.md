---
tags:
  - c语言
  - DataStructure
---

顺序表是**用一段地址连续的存储单元依次存储数据元素**的线性结构。



## 顺序表的定义 (Definition)

在 C 语言中，不仅仅需要一个数组来存数据，还需要一个变量来记录当前存了多少个数据。因此，通常使用 `struct`（结构体）将**数组**和**长度**封装在一起。

**顺序表在内存中是连续的**

### 静态分配

```c
#define MAX_SIZE 100  // 定义最大容量

typedef int ElemType; // 定义元素类型，方便修改（比如改成 float）

typedef struct {
    ElemType data[MAX_SIZE]; // 1. 存储数据的静态数组
    int length;              // 2. 当前顺序表的长度（有效元素个数）
} SqList;
```



### 动态分配

数据存放在堆区，可以动态扩容

```c
typedef int ElemType;

typedef struct {
    ElemType *data;  // 1. 指向动态分配数组的指针
    int MaxSize;     // 2. 顺序表的最大容量
    int length;      // 3. 当前长度
} SeqList;
```



## 顺序表的初始化 (Initialization)

初始化的目的是**构建一个空的顺序表**。



### 针对“静态分配”的初始化

```c
// 传入指针，因为我们需要修改原本的结构体变量
void InitList(SqList *L) {
    // 这里的 L 是指向结构体的指针，所以用 -> 访问成员
    L->length = 0; 
    // 注意：data 数组里的内容不需要清零，只要 length=0，
    // 我们就认为表是空的，旧数据会被覆盖。
}

// 主函数调用示例
int main() {
    SqList myList;
    InitList(&myList); // 必须传地址
    return 0;
}
```



### 针对“动态分配”的初始化



结构体内存分配在栈区：

```c
#include <stdlib.h> // 需要 malloc

#define INIT_SIZE 10 // 默认初始大小

void InitSeqList(SeqList *L) {
    // 1. 申请堆内存
    L->data = (ElemType *)malloc(sizeof(ElemType) * INIT_SIZE);
    
    // 2. 检查内存是否申请成功
    if (L->data == NULL) {
        // 内存分配失败处理
        return;  //立即结束函数执行并返回到调用点
    }

    // 3. 初始化属性
    L->length = 0;           // 当前没有元素
    L->MaxSize = INIT_SIZE;  // 记录最大容量
}
```



结构体内存分配在堆区：

```c
SeqList* initList() { 
  SeqList *L=(SeqList*)malloc(sizeof(SeqList))
```





## 顺序表的插入 (Insertion)

核心逻辑：给新来的腾位置

在顺序表中，因为内存是连续的，必须通过**数据搬运**来实现。



### 插入步骤

假设要把元素 `e` 插入到顺序表的第 `i` 个位置（ `i` 是数组下标，从 0 开始）：

1. **判满**：检查表是不是已经满了（`length == MaxSize`）。防止越界溢出。
2. **判错**：检查插入位置 `i` 是否合法。
3. **搬运**：**从最后一个元素开始**，依次向后移动一位，直到把第 `i` 个位置腾出来。
   - *注意：一定要从后往前搬，否则会覆盖掉前面的数据！*
4. **写入**：把新元素 `e` 放入 `data[i]`。
5. **更新**：表长 `length` 加 1



### 相关代码

```c
#include <stdio.h>
#include <stdbool.h> // 使用 bool 类型

#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int length;
} SqList;

// 函数功能：在 index 位置插入元素 e
// 返回值：true 表示成功，false 表示失败
bool ListInsert(SqList *L, int index, int e) {
    // 1. 判断是否已满
    if (L->length >= MAX_SIZE) {
        printf("插入失败：表已满\n");
        return false;
    }

    // 2. 判断位置是否合法
    // 允许插入的位置是 0 到 length (插在末尾)
    if (index < 0 || index > L->length) {
        printf("插入失败：位置不合法\n");
        return false;
    }

    // 3. 移动元素 (核心代码)
    // j 代表当前要移动的元素的下标
    // 从最后一个元素 (length-1) 开始，直到 index 位置的元素都要移动
    for (int j = L->length - 1; j >= index; j--) {
        L->data[j + 1] = L->data[j]; // 把数据往后挪一位
    }

    // 4. 放入新元素
    L->data[index] = e;

    // 5. 长度 +1
    L->length++;
    
    return true;
}
```


### 插入的时间复杂度
时间复杂度最小是1,最大是n[[算法分析#^3292b4|时间复杂度]]



## 顺序表的删除

将指定位置（下标）的元素移除，并保持剩余元素的连续性。

由于顺序表底层是**数组**，删除一个元素后，为了保证内存空间的连续性，必须将该位置之后的所有元素**向前平移**。

数组的最后一个位置确实会保留原来的旧值（形成重复），但**不需要专门去删除”**。



### 删除步骤

假设要删除顺序表中下标为 $i$ 的元素：

1. **检查合法性**：判断删除位置 $i$ 是否在有效范围内（$0 \le i < \text{length}$）。
2. **取出元素**（可选）：将要删除的元素值保存，返回给调用者。
3. **元素平移**：将从 $i+1$ 到 $n-1$ 的所有元素依次向前移动一个位置。
4. **更新长度**：顺序表的长度减 1。



### 相关代码

```c
#define MAXSIZE 100

typedef struct {
    int data[MAXSIZE]; // 存储元素的数组
    int length;        // 当前长度
} SeqList;

/**
 * 删除顺序表中指定位置的元素
 * @param L 顺序表指针
 * @param i 删除位置的下标
 * @param e 用于存储被删除元素的指针
 * @return 1 表示成功，0 表示失败
 */
int ListDelete(SeqList *L, int i, int *e) {
    // 1. 检查下标是否越界
    if (i < 0 || i >= L->length) {
        return 0; 
    }

    // 2. 暂存被删除的值
    *e = L->data[i];

    // 3. 将删除位置之后的元素依次向前平移
    for (int j = i; j < L->length - 1; j++) {
        L->data[j] = L->data[j + 1];
    }

    // 4. 表长减 1
    L->length--;
    return 1;
}
```





### 时间复杂度分析

顺序表的删除操作效率主要取决于移动元素的次数：

- **最好情况**：删除最后一个元素。不需要移动元素，时间复杂度为 $O(1)$。
- **最坏情况**：删除第一个元素（下标 0）。所有剩余元素都要向前移动，时间复杂度为 $O(n)$。
- **平均情况**：平均移动次数为 $\frac{n-1}{2}$，因此平均时间复杂度依然是 **$O(n)$**。



## 值传递**与**地址传递



### 数据流向

#### 插入（Insert）：数据“进入”表

在插入操作中，已经知道了要插入的具体数值（比如要把数字 `100` 存进去）。

- **流向**：主函数 $\rightarrow$ 插入函数 $\rightarrow$ 顺序表。
- **方式**：函数只需要读取这个值并复制到数组里。使用 `int e`（值传递）就足够了，因为函数内部不需要修改主程序中那个变量本身。

#### 2. 删除（Delete）：数据“传出”表

在删除操作中，不仅把元素从表里删掉，还想知道**刚才删掉的那个值到底是什么**（比如为了后续的释放内存、记录日志或逻辑判断）。

- **流向**：顺序表 $\rightarrow$ 删除函数 $\rightarrow$ 主函数。
- **方式**：由于 C 语言的 `return` 语句通常只能返回一个值（而删除函数已经用 `return` 返回了执行成功或失败的状态，即 `1` 或 `0`），需要另一种方式把“被删掉的值”带回到主程序中。
- 通过指针实现“多返回值”



### 为什么删除不能用 `int e`

如果写成 `int ListDelete(..., int e)`，那么在函数内部执行 `e = L->data[i]`。 根据 C 语言的规则，这只是修改了函数内部的一个**临时副本**，当函数结束时，这个副本就销毁了，主程序里的那个变量依然没有得到被删除的值。



## 顺序表查找

按值查找 (Locate Element by Value)：找某个特定的数值（比如“在这个表里找有没有 88 这个数”），并返回它的位置。



### 相关代码

```c
/**
 * 按值查找
 * @param L 顺序表
 * @param e 要查找的目标值
 * @return 返回该元素的“逻辑位置”（第几个），如果没找到返回 0
 */
int LocateElem(SeqList L, int e) {
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == e) {
            return i + 1; // 找到了！返回它是“第几个”（下标+1）
        }
    }
    return 0; // 找遍了都没找到
}
```

